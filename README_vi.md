![ACM-ICPC](https://github.com/hieunv1996/ACM-ICPC-Preparation/blob/master/acm_icpc_prep.jpg "ACM-ICPC")

# Lộ trình ôn thi Olympic tin học & ACM-ICPC 
![](https://img.shields.io/badge/NAU-in%20progress-blue.svg) ![](https://img.shields.io/badge/licence-MIT-green.svg) ![](https://img.shields.io/badge/Weeks%20Completed-8%2F20-orange.svg)

Lộ trình này được xây dựng để chuẩn bị cho việc ôn thi Olympic tin học SV & ACM-ICPC, **nhưng bạn cũng có thể sử dụng để:**
  - Các kỳ thi lập trình khác
  - chuẩn bị cho các bài thi phỏng vấn
  - Nâng cao kỹ năng thuật toán
  - Phục vụ các môn tại trường học
  - Đam mê

**Yêu cầu với người học:**
  - Biết ít nhất một ngôn ngữ lập trình(_Bạn phải có khả năng lập trình với ngôn ngữ đó_)
  - Có kiến thức & hiểu biết cơ bản về các Cấu trúc dữ liệu cơ bản(Mảng, Stack, Queue,...)(_Nếu bạn không biết một trong số đó, hãy học nó khi cần sử dụng trong lộ trình này_)

###### _PS: Tôi có nói "Bất kỳ ngôn ngữ nào", nhưng trong lộ trình này hầu hết sử dụng C, C++ và một chút Java, bạn vẫn có thể follow lộ trình này mà không nhất định phải biết các ngôn ngữ đó_

Trong lộ trình ôn thi OLP & ACM này chúng tôi sẽ chia sẻ link tới các tài nguyên, chúng tôi khi viết lại những gì đã có. Chúng tôi chỉ sưu tập các tài nguyên hữu ích lại một chỗ, và bạn có thể dễ dàng follow để học. Lộ trình này cũng bao gồm các thuật toán và cấu trúc dữ liệu. Bạn nên follow lộ trình này theo từng tuần đã được chúng tôi chỉ định.

**Hướng dẫn dành cho bạn:**
  1. Đi tới nguồn tài nguyên cần học
  2. Tập trung suy nghĩ, cố gắng code và đừng xem lời giải
  3. Khi bạn gặp khó khắn(bạn đã cố gắng hết sức) hoặc đã hoàn thành nhiệm vụ, hãy xem lời giải, so sánh với lời giải của bạn và xem đâu là lời giải tốt nhất cho bài toán đó. Bạn có thể sẽ tìm được những thứ hay ho từ lời giải của người khác.
  4. Khi bạn cảm thấy hài lòng với kiến thức có được, hãy nhớ giải quyết các bài toán của phần kiến thức đó.
  5. Khi bạn hoàn thành hay gặp rắc rối, xem xét các lời giải khác và tìm xem bạn gặp lỗi gì và thấy được một lời giải tốt hơn.

## Tài nguyên sử dụng

Trong lộ trình ôn thi OLP & ACM này chúng tôi sẽ sử dụng một số tài nguyên cho việc luyện tập. Như đã nói ở trên, các bài toán đã có sẵn, chúng tôi chỉ giúp bạn thấy chúng dễ dàng hơn. Đây là các website/công cụ chúng tôi sử dụng trong suốt lộ trình:
  - [Leetcode](https://leetcode.com)
  - [Spoj](http://www.spoj.com)
  - [Hackerrank](https://www.hackerrank.com/domains)
  - [Topcoder](https://www.topcoder.com)
  - [Codeforces](http://codeforces.com)
  - [Lightoj](http://www.lightoj.com)
  - [ACM-Timus](http://acm.timus.ru)

Tôi cung cấp tên của chúng bởi vì có thể bạn sẽ không thể nộp lời giải của bạn hoặc xem bài toán. Vấn đề sẽ tốt hơn nếu bạn tạo cho mình một tài khoản trên đó.

## Các kiến thức cần học

Đây là danh sách các chủ đề có trong lộ trình này..

### Cấu trúc dữ liệu(DS)

  - Stacks
  - Queues
  - Priority queue
  - Hashmap
  - Linked List
  - Trees
  - Heaps
  - Advanced Trees 
    - Tries
    - Segment trees
    - Fenwick tree or Binary indexed trees
    - RMQ
  - SQRT Decomposition
  - Disjoint Data Structure
  - C++ STL (optional)

### Giải thuật(Algo)

  - Number Theory 
    - Prime Numbers (Sieve of Eratosthenes)
    - GCD and LCM Euclid’s Algorithm
    - Modular Exponentiation
    - Long arithmetic (Multi, Add)
    - Efficient Prime Factorization

  - Combinatorics(Probability-Combinations-Permutations-Matrix..)

  - Computational geometry
    - Primitive Operations
      - Intuition
      - Polygon Inside, Outside
      - Implementing CCW
      - Immutable Point ADT
    - Convex Hull
    - Closest pair problem
    - Line intersection

  - Sorting
    - QuickSort
    - Counting Sort
    - Merge Sort

  - Searching
    - Binary Search
    - Ternary Search

  - Graph Theory
    - Depth First Search (DFS)
    - Breadth First Search (BFS)
    - Dijkstra’s Shortest Path
    - Minimum Spanning Tree 
    - Ford Bellman
    - Floyd Warshall
    - LCA (Lowest Common Ancestor)
    - Max Flow / Min Cut

  - Dynamic programming
    - Knapsack
    - Matrix chain multiplication
    - Coin Change
    - Kadane
    - Longest increasing Subsequence (with RMQ)

  - Strings
    - Z algorithm
    - Suffix Trees/Arrays
    - Knuth-Morris-Pratt Algorithm (KMP)
    - Rabin-Karp Algorithm
    - Hash

  - Bit Manipulation

  - Game theory
    - Nim game
    - Grundy numbers
    - Sprague-Grundy theorem

  - **Optional Advanced Algorithms**
    - AVL Trees
    - Graph Coloring
    - Mo's Algorithm
    - Palindromic Tree
    - Heavy Light Decomposition
    - Dynamic Programming by Profile
    - Rod Cutting
    - Topological Sorting
    - DP with Bitmask - Dynamic Programming
    - Diobhantine Equation - Math
    - Flood Fill - Graph


## Lộ trình học
|Week|Topics|Optional Topics|
| --- | --- | --- |
|[**Heads Up **](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week00)|<ul><li>Big O Notation</li></ul>||
|[**Week 1**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week01)|<ul><li>Prime Numbers (Sieve of Eratosthenes)</li><li>Efficient Prime Factorization</li><li>Modular Exponentiation</li></ul>||
|[**Week 2**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week02)|<ul><li>GCD and LCM Euclid’s Algorithm</li><li>Long arithmetic (Multi, Sum, Div, Sub)</li></ul>|<ul><li>C++ STL:Vector</li><li>C++ STL:Pairs</li><li>C++ STL:Iterators</li></ul>|
|[**Week 3**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week03)|<ul><li>QuickSort</li><li>Counting Sort</li></ul>|<ul><li>C++ STL:String</li><li>C++ STL:Set</li><li>C++ STL:Map</li></ul>|
|[**Week 4**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week04)|<ul><li>Merge Sort</li><li>Binary Search</li></ul>|<ul><li>Ternary Search</li></ul>|
|[**Week 5**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week05)|<ul><li>Queue (DS)</li><li>Stack (DS)</li><li>Breadth First Search</li><li>Depth First Search</li></ul>|<ul><li>C++ STL: Queue</li><li>C++ STL: Stack</li></ul>|
|[**Week 6**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week06)|<ul><li>Linked List (DS)</li><li>Dijkstra’s Shortest Path</li><li>Minimum Spanning Tree (MST)</li><li>Floyd Warshall</li></ul>|<ul><li>Cycle Detection (Union Find)</li></ul>|
|[**Week 7**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week07)|<ul><li>Knapsack</li><li>Coin Change</li><li>Kadane</li></ul>||
|[**Week 8**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week08)|**Questions from previous topics**||
|[**Week 9**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week09)|<ul><li>Trees (DS)</li><li>Segment Trees (DS)</li><li>Range Minimum Query (RMQ)</li><li>Lowest Common Ancestor (LCA)</li></ul>|<ul><li>Topological Sorting</li></ul>|
|[**Week 10**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week10)|<ul><li>Ford Bellman</li><li>Max Flow / Min Cut</li><li>Longest increasing Subsequence (with RMQ)</li></ul>|<ul><li>Heavy Light Decomposition</li></ul>|
|[**Week 11**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week11)|<ul><li>Primitive Operations<ul><li>Intuition</li><li>Polygon Inside, Outside</li><li>Implementing CCW</li><li>Immutable Point ADT</li></ul></li><li>Convex Hull</li><li>Closest pair problem</li><li>Line intersection</li></ul>||
|[**Week 12**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week12)|<ul><li>Tries (DS)</li><li>Suffix Trees/Arrays (DS)</li><li>Knuth-Morris-Pratt Algorithm (KMP)</li><li>Rabin-Karp Algorithm</li></ul>||
|[**Week 13**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week13)|<ul><li>Heaps (DS)</li><li>Priority queue (DS)</li><li>Combinatorics</li></ul>||
|[**Week 14**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week14)|<ul><li>Z algorithm</li><li>Hash</li><li>Disjoint Data Structure (DS)</li></ul>||
|[**Week 15**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week15)|<ul><li>Matrix chain multiplication</li><li>SQRT Decomposition (DS)</li></ul>|<ul><li>Mo's Algorithm</li><li>Rod Cutting</li></ul>|
|[**Week 16**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week16)|**Questions from previous topics**||
|[**Week 17**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week17)|<ul><li>Nim game</li><li>Grundy numbers</li></ul>||
|[**Week 18**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week18)|<ul><li>Sprague-Grundy theorem</li><li>Fenwick tree or Binary indexed trees (DS)</li></ul>||
|[**Week 19**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week19)|<ul><li>Bit Manipulation</li></ul>|<ul><li>Palindromic Tree</li><li>AVL Trees</li></ul>|
|[**Week 20**](https://github.com/hieunv1996/ACM-ICPC-Preparation/tree/master/Week20)|<ul><li>Heavy Light Decomposition</li><li>Dynamic Programming by Profile</li></ul>|<ul><li>Graph Coloring</li></ul>|


### [Contributers](https://github.com/hieunv1996/ACM-ICPC-Preparation/graphs/contributors)

###### An [ACM-ICPC Prepare](https://nguyenvanhieu.vn) tutorial
